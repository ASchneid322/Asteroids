//***********************************************************************************
//Program:					Shapes
//Description:	            Shape base for asteroids game
//Date:						March 23rd
//Authors:					Alexander Schneider
//Course:					CMPE2700
//Class:					CNTA02
//***********************************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Drawing;
using System.Drawing.Drawing2D;

namespace Asteroids1._0
{
    ////////////////////////////////
    // ShapeBase class 
    //  Moving shapes
    ///////////////////////////////
    public abstract class ShapeBase
    {
        //Center point for the shape
        public PointF _pos { get; protected set; }
        //Current rotation of the shape
        protected float _rot;
        //How much the rotation increases per tick
        protected float _rotInc;
        //Movement speed on X axis
        protected float _xSpeed;
        //Movement speed on Y axis
        protected float _ySpeed;
        //Randon generator for speed/rotation/shape generation
        protected static Random s_rnd = new Random();
        //Const for the size of all the shapes.
        //Public for the outside of the class to see
        //the size of the blocks.
        public const int _tileSize = 50;
        //Scale of the objects
        public float _scale;

        /// ///////////////////
        /// Constructor for shapebase.
        /// Takes a position for the initial spot.
        /// Generates a speed from -2.5 to 2.5 and
        /// a rotation speed of -3 to 3.
        /// //////////////////
        public ShapeBase(float scale, PointF position)
        {
            _pos = position;
            _rot = 0;
            _scale = scale;
            _rotInc = (float)(s_rnd.NextDouble() * 6 - 3);
            _xSpeed = (float)(s_rnd.NextDouble() * 5 - 2.5);
            _ySpeed = (float)(s_rnd.NextDouble() * 5 - 2.5);
        }
        /// ////////////////////////////
        ///Default shape is a triangle if nothing is specified.
        /// ////////////////////////////
        public virtual GraphicsPath GetPath()
        {
            return generateShape(3, 1, 0);
        }
        /// /////////////////////////
        ///Render method for the shape. Creates the shape based off the GetPath()
        /// then draws a circle showing the area the shape covers.
        /// /////////////////////////
        public virtual void Render(Color fillColor, BufferedGraphics bg)
        {
            bg.Graphics.FillPath(new SolidBrush(fillColor), GetPath());

            //Ellipse must be centered by moving it half the size/2
            //bg.Graphics.DrawEllipse(new Pen(Color.Orange), _pos.X - _tileSize*3 / 2, _pos.Y - _tileSize*3 / 2, _tileSize*3, _tileSize*3);
        }

        /// ///////////////////////////
        /// Moves the object based off of their movement values.
        /// Needs the width and height of their movement area.
        /// //////////////////////////
        public virtual void Tick(int width, int height)
        {
            //These two are for holding the new points of the shape.
            float newX;
            float newY;

            //Increase roation value of the shape.
            _rot += _rotInc;
            //Check position to check for bounce and make new position.
            newX = _pos.X;
            newY = _pos.Y;
            //Sets the position to the new point.
            _pos = new PointF(newX + _xSpeed, newY + _ySpeed);
        }

        /// //////////////////////
        /// Static method to create the GraphicsPath shape of the object.
        /// Uses amount of sides for the shape, max distance from the center and variance in distance from the center.
        /// Returns GraphicsPath of shape generated by parameters.
        /// /////////////////////
        public static GraphicsPath generateShape(int sides, float radMax, float radVariance)
        {
            //New model to store the path
            GraphicsPath model = new GraphicsPath();
            //List of points to draw the shape. 12 points is the max for an object.
            PointF[] pts = new PointF[13];
            float radius;

            //If more than 12 sides is used, throw exception.
            if (sides > 12 || sides < 3)
            {
                throw new ArgumentException("ShapeBase Argument Error: Sides must be between 3-12");
            }

            for (int i = 0; i < sides; i++)
            {
                //Gets the distance from the center point to the edge for this point. Cannot exceed
                //radMax, can only go lower.
                radius = (float)((radMax / 2) * (1 - radVariance * s_rnd.NextDouble()));

                //Generate the point with sin or cos of 2pi * (i/sides) for position.
                // sides * 1.0 to force non integer math.
                pts[i] = new PointF((float)(radius * Math.Cos(Math.PI * 2.0 * (i / (sides * 1.0))))
                                  , (float)(radius * Math.Sin(Math.PI * 2.0 * (i / (sides * 1.0)))));

                //Add the first point to the end.
                //This is here because the shape is considered to have a point at the middle,
                //and this step completes the shape.
                if (i == 0)
                    pts[sides] = pts[i];
            }

            //Make the model and return it.
            model.StartFigure();
            model.AddPolygon(pts);
            model.CloseFigure();

            return model;
        }
    }
}